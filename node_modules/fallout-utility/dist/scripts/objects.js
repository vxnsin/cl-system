"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isJSONEncodable = exports.isClass = exports.recursiveObjectReplaceValues = exports.sliceIntoChunks = exports.getRandomKey = exports.normalizeArray = void 0;
const strings_1 = require("./strings");
const numbers_1 = require("./numbers");
const kleur_1 = __importDefault(require("kleur"));
/**
 * Normalize an array given from a rest param
 * @param array Rest data
 */
function normalizeArray(array) {
    return Array.isArray(array[0]) ? array[0] : array;
}
exports.normalizeArray = normalizeArray;
function getRandomKey(obj) {
    if (typeof obj !== "object")
        throw new TypeError(`type ${kleur_1.default.cyan(typeof obj)} is not an object.`);
    const keys = Array.isArray(obj) ? obj : Object.keys(obj);
    return keys[(0, numbers_1.randomInt)(0, (keys.length - 1))];
}
exports.getRandomKey = getRandomKey;
/**
 * Slice array values into chunks
 * @param arr Array to slice
 * @param chunkSize Chunk size
 */
function sliceIntoChunks(arr, chunkSize) {
    const res = [];
    for (let i = 0; i < arr.length; i += chunkSize) {
        const chunk = arr.slice(i, i + chunkSize);
        res.push(chunk);
    }
    return res;
}
exports.sliceIntoChunks = sliceIntoChunks;
function recursiveObjectReplaceValues(object, _find, _replace) {
    const find = typeof _find === 'object' ? _find : [_find];
    const replace = typeof _replace === 'object' ? _replace : [_replace];
    if (typeof object !== 'object')
        return typeof object !== 'string' ? object : (0, strings_1.replaceAll)(object, find, replace);
    if (Array.isArray(object))
        return object.map(v => typeof v === 'string' ? (0, strings_1.replaceAll)(v, find, replace) : recursiveObjectReplaceValues(v, find, replace));
    const keys = object ? Object.keys(object) : [];
    const values = Object.values(object);
    let newObject = {};
    let i = 0;
    for (const value of values) {
        newObject = {
            ...newObject,
            [keys[i]]: typeof value === 'string' || typeof value === 'object'
                ? recursiveObjectReplaceValues(value, find, replace)
                : value
        };
        i++;
    }
    return newObject;
}
exports.recursiveObjectReplaceValues = recursiveObjectReplaceValues;
/**
 * Check if an object is from a class
 * @param object Object to check
 */
function isClass(object) {
    const isClassConstructor = object.constructor && object.constructor.toString().substring(0, 5) === 'class';
    if (object.prototype === undefined)
        return isClassConstructor;
    const isPrototypeClassConstructor = object.prototype.constructor && object.prototype.constructor.toString && object.prototype.constructor.toString().substring(0, 5) === 'class';
    return isClassConstructor || isPrototypeClassConstructor;
}
exports.isClass = isClass;
/**
 * Checks if an object is JSON encodable or not
 * @param maybeEncodable Object to check
 */
function isJSONEncodable(maybeEncodable) {
    return maybeEncodable !== null && typeof maybeEncodable === 'object' && 'toJSON' in maybeEncodable;
}
exports.isJSONEncodable = isJSONEncodable;
