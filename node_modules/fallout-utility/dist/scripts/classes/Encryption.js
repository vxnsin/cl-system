"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Encryption = void 0;
const crypto_1 = require("crypto");
class Encryption {
    algorithm = 'aes-256-gcm';
    secret = (0, crypto_1.randomBytes)(16).toString('base64url');
    encoding = 'hex';
    ivLength = 16;
    saltLength = 64;
    pbkdf2Iterations = 100000;
    iv;
    salt;
    constructor(options) {
        this.algorithm = options?.algorithm ?? this.algorithm;
        this.secret = options?.secret ?? this.secret;
        this.ivLength = options?.ivLength ?? this.ivLength;
        this.saltLength = options?.saltLength ?? this.ivLength;
        this.pbkdf2Iterations = options?.pbkdf2Iterations ?? this.pbkdf2Iterations;
        this.encoding = options?.encoding ?? this.encoding;
        this.iv = (0, crypto_1.randomBytes)(this.ivLength);
        this.salt = (0, crypto_1.randomBytes)(this.saltLength);
    }
    saltSecret(options) {
        return (0, crypto_1.pbkdf2Sync)(this.secret, options?.salt ?? this.salt, options?.pbkdf2Iterations ?? this.pbkdf2Iterations, 32, 'sha512');
    }
    encrypt(value) {
        const key = this.saltSecret();
        const cipher = (0, crypto_1.createCipheriv)(this.algorithm, key, this.iv);
        const hash = Buffer.concat([cipher.update(String(value), 'utf-8'), cipher.final()]);
        const tag = cipher.getAuthTag();
        return {
            decrypted: value,
            encrypted: hash.toString(this.encoding),
            secret: this.secret,
            iv: this.iv.toString(this.encoding),
            salt: this.salt.toString(this.encoding),
            tag: tag.toString(this.encoding),
            pbkdf2Iterations: this.pbkdf2Iterations,
            encoding: this.encoding,
            algorithm: this.algorithm,
        };
    }
    decrypt(options) {
        const encoding = options.encoding ?? this.encoding;
        const iv = options?.iv ? Buffer.from(options.iv, encoding) : this.iv;
        const salt = options?.salt ? Buffer.from(options.salt, encoding) : this.salt;
        const tag = Buffer.from(options.tag, encoding);
        const encrypted = Buffer.from(options.encrypted, encoding);
        const key = this.saltSecret({ salt, pbkdf2Iterations: options?.pbkdf2Iterations ?? this.pbkdf2Iterations });
        const decipher = (0, crypto_1.createDecipheriv)(options?.algorithm ?? this.algorithm, key, iv);
        decipher.setAuthTag(tag);
        const decrypted = decipher.update(encrypted) + decipher.final('utf-8');
        return {
            decrypted: decrypted,
            encrypted: options.encrypted,
            secret: this.secret,
            iv: iv.toString(encoding),
            salt: salt.toString(encoding),
            tag: options.tag,
            pbkdf2Iterations: options.pbkdf2Iterations ?? this.pbkdf2Iterations,
            encoding,
            algorithm: options.algorithm ?? this.algorithm
        };
    }
    static encrypt(value, secret, encoding) {
        const encrypt = new Encryption({ secret });
        const encrypted = encrypt.encrypt(value);
        return Buffer.from(`${encodeURIComponent(encrypted.salt)} ${encodeURIComponent(encrypted.iv)} ${encodeURIComponent(encrypted.tag)} ${encodeURIComponent(encrypted.encrypted)}`, 'utf-8').toString(encoding ?? 'base64url');
    }
    static decrypt(encrypted, secret, encoding) {
        const data = Buffer.from(encrypted, encoding ?? 'base64url').toString('utf-8').split(' ');
        const encrypt = new Encryption({ secret });
        const decrypted = encrypt.decrypt({
            salt: data[0],
            iv: data[1],
            tag: data[2],
            encrypted: data[3]
        });
        return decrypted.decrypted;
    }
}
exports.Encryption = Encryption;
