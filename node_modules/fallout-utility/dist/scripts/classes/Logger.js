"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Logger = exports.LoggerLevel = void 0;
const fs_1 = require("fs");
const system_1 = require("../system");
const util_1 = require("util");
const path_1 = __importDefault(require("path"));
const strip_ansi_1 = __importDefault(require("strip-ansi"));
const TypedEmitter_1 = require("./TypedEmitter");
const ansi_regex_1 = __importDefault(require("ansi-regex"));
const zlib_1 = require("zlib");
const strings_1 = require("../strings");
var LoggerLevel;
(function (LoggerLevel) {
    LoggerLevel[LoggerLevel["INFO"] = 1] = "INFO";
    LoggerLevel[LoggerLevel["WARN"] = 2] = "WARN";
    LoggerLevel[LoggerLevel["ERROR"] = 3] = "ERROR";
    LoggerLevel[LoggerLevel["DEBUG"] = 4] = "DEBUG";
})(LoggerLevel = exports.LoggerLevel || (exports.LoggerLevel = {}));
class Logger extends TypedEmitter_1.TypedEmitter {
    parent;
    formatMessage;
    formatMessageLines;
    objectInspectOptions;
    enableDebugmode;
    forceEmitLogEvents;
    writeStream;
    name;
    get isDebugging() {
        return this.enableDebugmode || (0, system_1.isDebugging)();
    }
    constructor(options) {
        super();
        this.formatMessage = options?.formatMessage;
        this.formatMessageLines = options?.formatMessageLines ?? {};
        this.objectInspectOptions = options?.objectInspectOptions ?? { colors: true };
        this.enableDebugmode = options?.enableDebugmode ?? null;
        this.forceEmitLogEvents = options?.forceEmitLogEvents ?? false;
        this.writeStream = options?.writeStream || undefined;
        this.name = options?.name || undefined;
        this.parent = options?.parent || undefined;
        this.info = this.info.bind(this);
        this.warn = this.warn.bind(this);
        this.err = this.err.bind(this);
        this.log = this.log.bind(this);
        this.warning = this.warning.bind(this);
        this.error = this.error.bind(this);
        this.debug = this.debug.bind(this);
        this.logToFile = (0, util_1.deprecate)(this.logToFile.bind(this), "'<Logger>.logToFile' is deprecated. Use '<Logger>.createFileWriteStream()' instead.");
        this.createFileWriteStream = this.createFileWriteStream.bind(this);
        this.setDebugMode = this.setDebugMode.bind(this);
        this.setName = this.setName.bind(this);
        this.setWriteStream = this.setWriteStream.bind(this);
        this.closeWriteStream = this.closeWriteStream.bind(this);
        this.clone = this.clone.bind(this);
    }
    emit(eventName, ...args) {
        const emitted = super.emit(eventName, ...args);
        if (this.parent)
            this.parent.emit(eventName, ...args);
        return emitted;
    }
    info(...message) { this.log(...message); }
    warn(...message) { this.warning(...message); }
    err(...message) { this.error(...message); }
    log(...messages) {
        const message = this._print(messages, LoggerLevel.INFO).join('\n');
        this._write(message, LoggerLevel.INFO);
        this.emit('log', message);
    }
    warning(...messages) {
        const message = this._print(messages, LoggerLevel.WARN).join('\n');
        this._write(message, LoggerLevel.WARN);
        this.emit('warn', message);
    }
    error(...messages) {
        const message = this._print(messages, LoggerLevel.ERROR).join('\n');
        this._write(message, LoggerLevel.ERROR);
        this.emit('err', message);
    }
    debug(...messages) {
        const message = this._print(messages, LoggerLevel.DEBUG).join('\n');
        if (this.forceEmitLogEvents && !this.isDebugging)
            this.emit('debug', message);
        if (!this.isDebugging)
            return;
        this._write(message, LoggerLevel.DEBUG);
        this.emit('debug', message);
    }
    /**
     * @deprecated Use {@link Logger.createFileWriteStream} instead
     */
    logToFile(filePath, keepOldFile = false, renameFileName) {
        if (this.writeStream)
            throw new Error('Logger write stream already exist.');
        const filePathInfo = path_1.default.parse(filePath);
        (0, fs_1.mkdirSync)(filePathInfo.dir, { recursive: true });
        if ((0, fs_1.existsSync)(filePath) && !keepOldFile) {
            const fileInfo = (0, fs_1.lstatSync)(filePath);
            const dateFormat = `${fileInfo.birthtime.toDateString()} - ${fileInfo.birthtime.getHours()}-${fileInfo.birthtime.getMinutes()}-${fileInfo.birthtime.getSeconds()}-${fileInfo.birthtime.getMilliseconds()}`;
            (0, fs_1.renameSync)(filePath, path_1.default.join(filePathInfo.dir, renameFileName
                ? typeof renameFileName === 'string'
                    ? renameFileName
                    : renameFileName(fileInfo)
                : `${dateFormat}${filePathInfo.ext}`));
        }
        this.setWriteStream((0, fs_1.createWriteStream)(filePath));
        return this;
    }
    async createFileWriteStream(options) {
        if (this.writeStream)
            throw new Error('Logger write stream already exist.');
        const file = path_1.default.resolve(options.file);
        const filePathInfo = path_1.default.parse(file);
        (0, fs_1.mkdirSync)(filePathInfo.dir, { recursive: true });
        if ((0, fs_1.existsSync)(file) && options.renameOldFile !== false) {
            if (options.handleOldFile) {
                await Promise.resolve(options.handleOldFile(file));
            }
            else {
                const date = (0, fs_1.lstatSync)(file).birthtime.toISOString();
                const dateFormat = `${date.substring(0, 10)} ${(0, strings_1.replaceAll)(date.substring(11, 19), ':', '-')}`;
                const newFile = path_1.default.join(filePathInfo.dir, `${dateFormat}${filePathInfo.ext}.gz`);
                const data = (0, zlib_1.gzipSync)((0, fs_1.readFileSync)(file, 'utf-8'));
                (0, fs_1.renameSync)(file, newFile);
                (0, fs_1.writeFileSync)(newFile, data);
            }
        }
        this.setWriteStream((0, fs_1.createWriteStream)(options.file));
        return this;
    }
    setDebugMode(enabled) {
        this.enableDebugmode = enabled;
        return this;
    }
    setName(name) {
        this.name = name;
        return this;
    }
    setWriteStream(writeStream, close = true) {
        if (this.writeStream && close)
            this.writeStream.close();
        this.writeStream = writeStream;
        return this;
    }
    closeWriteStream() {
        this.writeStream?.close();
        this.writeStream = undefined;
        return this;
    }
    clone(options) {
        return new Logger({
            ...this,
            ...options
        });
    }
    _print(messages, level) {
        const formatter = this.formatMessage
            ? (message) => (this.formatMessage)(message, level, this)
            : this.formatMessageLines[level] ?? (e => e);
        if (!messages.length)
            this._write(formatter('', this), level);
        let lastAnsi = '';
        let lines = messages.map(msg => typeof msg === 'string' ? msg : (0, util_1.inspect)(msg, this.objectInspectOptions))
            .join(' ')
            .split('\n');
        lines = lines.map((msg, index) => {
            const previousLine = lines[index - 1];
            if (!previousLine)
                return formatter(msg, this);
            lastAnsi = previousLine.match((0, ansi_regex_1.default)())?.pop() ?? lastAnsi;
            return formatter(lastAnsi + msg, this);
        });
        return lines;
    }
    _write(message, level, logToConsole = true, logToFile = true) {
        if (logToConsole) {
            switch (level) {
                case LoggerLevel.INFO:
                    console.log(message);
                    break;
                case LoggerLevel.WARN:
                    console.warn(message);
                    break;
                case LoggerLevel.ERROR:
                    console.error(message);
                    break;
                case LoggerLevel.DEBUG:
                    console.debug(message);
                    break;
            }
        }
        if (logToFile) {
            const strippedMessage = (0, strip_ansi_1.default)(message);
            this.writeStream?.write(`${strippedMessage}\n`, 'utf-8');
        }
    }
}
exports.Logger = Logger;
